<!--
  @Author: lize
  @Date: 2021/6/17
  @Description : 
  @Parames :
  @Example :
  @Last Modified by: lize
  @Last Modified time: 2021/6/17
 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <pre>
        <h2>Set</h2>
        const set = new Set();
        给set里面加值的时候，使用set.add(); 他可以接受数组和对象。 成员的值都是唯一的，没有重复的值。
        1、// 去除数组的重复成员    [...new Set(array)]     Array.from(new Set(array));
        2、// 去除字符串里面的重复   [...new Set('ababbc')].join('')
        3、向 Set 加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值。 它类似于精确相等运算符（===）。另外，两个对象总是不相等的。
            let set = new Set();
            set.add({});
            set.size // 1
            set.add({});
            set.size // 2
        4、Set 结构的实例有以下属性。
                Set.prototype.constructor：构造函数，默认就是Set函数。
                Set.prototype.size：返回Set实例的成员总数。
                Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
                Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
                Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
                Set.prototype.clear()：清除所有成员，没有返回值。
        5、Set 结构的实例有四个遍历方法，可以用于遍历成员。
                Set.prototype.keys()：返回键名的遍历器
                Set.prototype.values()：返回键值的遍历器
                Set.prototype.entries()：返回键值对的遍历器
                Set.prototype.forEach()：使用回调函数遍历每个成员
            需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

        <h2>WeakSet</h2>
        WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
        ES6 规定 WeakSet 不可遍历。 const ws = new WeakSet(); 实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。
        WeakSet 没有size属性，没有办法遍历它的成员。
        const a = [[1, 2], [3, 4]];
        const ws = new WeakSet(a);
        WeakSet 结构有以下三个方法。
            WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
            WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
            WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
        <h2>Map</h2>
        它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
        const m = new Map();
        const o = {p: 'Hello World'};
        m.set(o, 'content')
        m.get(o) // "content"
        m.has(o) // true
        m.delete(o) // true
        m.has(o) // false
        Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
        const map = new Map([
            ['name', '张三'],
            ['title', 'Author']
        ]);
        map.size // 2
        map.has('name') // true
        map.get('name') // "张三"
        map.has('title') // true
        map.get('title') // "Author"
        如果对同一个键多次赋值，后面的值将覆盖前面的值。
        const map = new Map();
        map
         .set(1, 'aaa')
         .set(1, 'bbb');
        map.get(1) // "bbb"
        Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，
        我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。
        实例的属性和操作方法
        1、size 属性
        2、set(key, value)  set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，
            否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。
        3、get()  get方法读取key对应的键值，如果找不到key，返回undefined。
        4、has(key)  has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
        5、delete(key)  delete方法删除某个键，返回true。如果删除失败，返回false。
        6、clear() clear方法清除所有成员，没有返回值。
        7、Map 结构原生提供三个遍历器生成函数和一个遍历方法。 需要特别注意的是，Map 的遍历顺序就是插入顺序。
            Map.prototype.keys()：返回键名的遍历器。
            Map.prototype.values()：返回键值的遍历器。
            Map.prototype.entries()：返回所有成员的遍历器。
            Map.prototype.forEach()：遍历 Map 的所有成员。
        8、Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。
            const map = new Map([
              [1, 'one'],
              [2, 'two'],
              [3, 'three'],
            ]);
            [...map.keys()]// [1, 2, 3]
            Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历
            map.forEach(function(value, key, map) {
                this.report(key, value);
            }, reporter);
    </pre>
</body>
</html>